<!DOCTYPE html>
<html>
<head>
    <title>Towers Battle 3D</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-family: Arial, sans-serif;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        .button {
            width: 80px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 3px solid black;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        .button:hover { background-color: rgba(255, 255, 255, 1); }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
    <div id="info">
        <p>–ò–≥—Ä–æ–∫: –ó–æ–ª–æ—Ç–æ: <span id="gold1">0</span> | –ñ–∏–∑–Ω–∏: <span id="hp1">100</span> | –û—á–∫–∏: <span id="score1">0</span></p>
        <p>–ò–ò: –ó–æ–ª–æ—Ç–æ: <span id="gold2">0</span> | –ñ–∏–∑–Ω–∏: <span id="hp2">100</span></p>
    </div>
    <div id="controls">
        <div class="button" id="heal">
            <span style="font-size: 30px;">‚ù§Ô∏è</span>
            <span>–õ–µ—á–µ–Ω–∏–µ</span>
        </div>
        <div class="button" id="buy_cannon">
            <span style="font-size: 30px;">üî´</span>
            <span>–ü—É—à–∫–∞</span>
        </div>
        <div class="button" id="upgrade">
            <span style="font-size: 30px;">‚¨ÜÔ∏è‚¨ÜÔ∏è</span>
            <span>–£–ª—É—á—à–µ–Ω–∏–µ</span>
        </div>
    </div>
    <script type="text/javascript">
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 10, 10);
        scene.add(light);

        // –ë–∞—à–Ω–∏
        const towerGeometry = new THREE.CylinderGeometry(15, 15, 60, 32);
        const playerTowerMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const aiTowerMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const playerTower = new THREE.Mesh(towerGeometry, playerTowerMaterial);
        const aiTower = new THREE.Mesh(towerGeometry, aiTowerMaterial);
        playerTower.position.set(-50, 30, 0);
        aiTower.position.set(50, 30, 0);
        scene.add(playerTower);
        scene.add(aiTower);

        // –ü—É—à–∫–∏
        const cannonGeometry = new THREE.SphereGeometry(7, 32, 32);
        const cannons = {
            player: [{ mesh: new THREE.Mesh(cannonGeometry, new THREE.MeshPhongMaterial({ color: 0x006600 })), damage: 1, cooldown: 0, speed: 2 }],
            ai: [{ mesh: new THREE.Mesh(cannonGeometry, new THREE.MeshPhongMaterial({ color: 0x660000 })), damage: 1, cooldown: 0, speed: -2 }]
        };
        cannons.player[0].mesh.position.set(-50, 15, 0);
        cannons.ai[0].mesh.position.set(50, 15, 0);
        scene.add(cannons.player[0].mesh);
        scene.add(cannons.ai[0].mesh);

        // –Ø–¥—Ä–∞
        const projectileGeometry = new THREE.SphereGeometry(3, 16, 16);
        const projectiles = [];

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        let gameState = {
            towers: [{ hp: 100 }, { hp: 100 }],
            gold: [0, 0],
            score: 0,
            gameOver: false,
            goldTimer: 0,
            healCost: 100
        };

        // –ö–∞–º–µ—Ä–∞ (–¥–∞–ª—å—à–µ –æ—Ç —Å—Ü–µ–Ω—ã)
        camera.position.z = 180;  // –û—Ç–æ–¥–≤–∏–Ω—É—Ç–∞ –¥–∞–ª—å—à–µ
        camera.position.y = 80;   // –ß—É—Ç—å –≤—ã—à–µ –¥–ª—è –æ–±–∑–æ—Ä–∞
        camera.lookAt(0, 30, 0);

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        function updateInfo() {
            document.getElementById("gold1").textContent = gameState.gold[0];
            document.getElementById("gold2").textContent = gameState.gold[1];
            document.getElementById("hp1").textContent = gameState.towers[0].hp;
            document.getElementById("hp2").textContent = gameState.towers[1].hp;
            document.getElementById("score1").textContent = gameState.score;
        }

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∞–º–∏
        document.getElementById("heal").addEventListener("click", () => {
            if (gameState.gold[0] >= gameState.healCost && !gameState.gameOver) {
                gameState.towers[0].hp += 50;
                gameState.gold[0] -= gameState.healCost;
                gameState.healCost += 40;
            }
        });
        document.getElementById("buy_cannon").addEventListener("click", () => {
            if (cannons.player.length < 4 && !gameState.gameOver) {
                const costs = [100, 200, 300];
                const cost = costs[cannons.player.length - 1] || 300;
                if (gameState.gold[0] >= cost) {
                    const newCannon = {
                        mesh: new THREE.Mesh(cannonGeometry, new THREE.MeshPhongMaterial({ color: 0x006600 })),
                        damage: 1,
                        cooldown: 0,
                        speed: 2
                    };
                    newCannon.mesh.position.set(-50, 15 + cannons.player.length * 15, 0);
                    cannons.player.push(newCannon);
                    scene.add(newCannon.mesh);
                    gameState.gold[0] -= cost;
                }
            }
        });
        document.getElementById("upgrade").addEventListener("click", () => {
            if (gameState.gold[0] >= 150 && !gameState.gameOver) {
                cannons.player.forEach(cannon => cannon.damage += 1);
                gameState.gold[0] -= 150;
            }
        });

        // –ê–Ω–∏–º–∞—Ü–∏—è
        function animate() {
            requestAnimationFrame(animate);

            if (gameState.gameOver) {
                return;
            }

            // –ó–æ–ª–æ—Ç–æ (4 –µ–¥–∏–Ω–∏—Ü—ã –≤ —Å–µ–∫—É–Ω–¥—É)
            gameState.goldTimer += 1;
            if (gameState.goldTimer >= 60) {
                gameState.gold[0] += 4;
                gameState.gold[1] += 4;
                gameState.goldTimer = 0;
            }

            // –°—Ç—Ä–µ–ª—å–±–∞ (3 —Å–µ–∫—É–Ω–¥—ã)
            [cannons.player, cannons.ai].forEach(playerCannons => {
                playerCannons.forEach(cannon => {
                    cannon.cooldown += 1;
                    if (cannon.cooldown >= 180) {
                        const proj = new THREE.Mesh(projectileGeometry, new THREE.MeshPhongMaterial({ color: cannon.mesh.material.color }));
                        proj.position.set(cannon.mesh.position.x, cannon.mesh.position.y, cannon.mesh.position.z);
                        projectiles.push({ mesh: proj, dx: cannon.speed, damage: cannon.damage });
                        scene.add(proj);
                        cannon.cooldown = 0;
                    }
                });
            });

            // –î–≤–∏–∂–µ–Ω–∏–µ —è–¥–µ—Ä
            projectiles.forEach((proj, index) => {
                proj.mesh.position.x += proj.dx;
                const target = proj.dx > 0 ? aiTower : playerTower;
                const targetPos = target.position;
                if (Math.abs(proj.mesh.position.x - targetPos.x) < 18 && Math.abs(proj.mesh.position.y - targetPos.y) < 30) {
                    const targetIndex = proj.dx > 0 ? 1 : 0;
                    gameState.towers[targetIndex].hp -= proj.damage;
                    if (proj.dx > 0) gameState.score += proj.damage;
                    scene.remove(proj.mesh);
                    projectiles.splice(index, 1);
                    if (gameState.towers[targetIndex].hp <= 0) {
                        gameState.gameOver = true;
                    }
                } else if (proj.mesh.position.x < -100 || proj.mesh.position.x > 100) {
                    scene.remove(proj.mesh);
                    projectiles.splice(index, 1);
                }
            });

            // –ò–ò (–ø–æ–∫—É–ø–∫–∞ –ø—É—à–µ–∫ –∏–ª–∏ –∑–¥–æ—Ä–æ–≤—å—è)
            if (gameState.gold[1] >= 100 && Math.random() < 0.01) {
                if (Math.random() < 0.5 && cannons.ai.length < 4) {
                    const costs = [100, 200, 300];
                    const cost = costs[cannons.ai.length - 1] || 300;
                    if (gameState.gold[1] >= cost) {
                        const newCannon = {
                            mesh: new THREE.Mesh(cannonGeometry, new THREE.MeshPhongMaterial({ color: 0x660000 })),
                            damage: 1,
                            cooldown: 0,
                            speed: -2
                        };
                        newCannon.mesh.position.set(50, 15 + cannons.ai.length * 15, 0);
                        cannons.ai.push(newCannon);
                        scene.add(newCannon.mesh);
                        gameState.gold[1] -= cost;
                    }
                } else if (gameState.gold[1] >= 100) {
                    gameState.towers[1].hp += 50;
                    gameState.gold[1] -= 100;
                }
            }

            updateInfo();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
